import make_x
import numpy as np
from numpy import argmax
from keras.models import Sequential
from keras.layers import Dense, Activation, Dropout

(trainX, trainY), (testX, testY) = make_x.data_load()
input_dim = trainX.shape[1]
model = Sequential()
x_val = trainX[:500]
x_train = trainX[500:]
y_val = trainY[:500]
y_train = trainY[500:]

model.add(Dense(10, input_dim=input_dim, init='uniform', activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(30, init='uniform', activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(1, init='uniform', activation='sigmoid'))

model.compile(loss='binary_crossentropy', optimizer='adam',metrics=['accuracy'])

model.fit(x_train, y_train, epochs=30, batch_size=300, validation_data=(x_val, y_val))

count = 0
count_ = 0
mal_count = 0
w_count = 0

predictions = model.predict(testX)
rounded = [x[0] for x in predictions]
for i in range(500):
	pre = predictions[i]
	if pre != 0.0:
		pre = 1
	print str(testY[i]) + " : " + str(pre)
	if int(testY[i])== 1:
		mal_count = mal_count + 1

	if int(testY[i]) == 1 and int(testY[i]) == int(pre):
		count = count + 1

	if int(testY[i]) == int(pre):
                count_ = count_ + 1			
	
	if int(testY[i]) == 0 and int(pre) == 1:
		w_count = w_count + 1

print "Wrong : " + str((float(w_count)/500)*100) # Wrong Detect 
print "Good  : " + str((float(mal_count-count)/float(mal_count))*100) # Good Detect
